using LinearAlgebra
using SparseArrays
using ArgCheck

function greet_fem()
    println("Hello, I am the FEM module")
end

mutable struct model
    ne::Int64
    NodeList::Matrix{Float64}
    IEN::Matrix{Int}
    IEN_top::Matrix{Int}
    IEN_btm::Matrix{Int}
    IEN_border::Matrix{Int}
    ndim::Int64
    nDof::Int64
    FunctionClass::String
    ID::Matrix{Int}
    Young::Float64
    ν::Float64
    cMat::Matrix{Float64}
    dcMatdλ::Matrix{Float64}
    dcMatdμ::Matrix{Float64}
end

function def_model(; ne::Int64 = 1, 
    NodeList::Matrix{Float64} = [0.0 1.0 1.1 0.1], 
    IEN::Matrix{Int} = [1 2 3 4], 
    ndim::Int64 = 2, 
    nDof::Int64 = 1, 
    FunctionClass::String = "Q1", 
    Young = 1.0, 
    ν = 0.3, 
    ID::Matrix{Int} = [1 2 3 4],
    cMat::Matrix{Float64} = [0.0 1.0 1.1 0.1],
    IEN_top::Matrix{Int} = [1 2 3 4],
    IEN_btm::Matrix{Int} = [1 2 3 4],
    IEN_border::Matrix{Int} = [1 2 3 4],
    dcMatdλ::Matrix{Float64} = [0.0 1.0 1.1 0.1],
    dcMatdμ::Matrix{Float64} = [0.0 1.0 1.1 0.1]
    )

    model(ne, NodeList, IEN, IEN_top, IEN_btm, IEN_border, ndim, nDof, FunctionClass, ID, Young, ν, cMat, dcMatdλ, dcMatdμ)
end

params(mdl::model) = "ne = $(mdl.ne), ndim = $(mdl.ndim), nDof = $(mdl.nDof), FunctionClass = $(mdl.FunctionClass), Young = $(mdl.Young), ν = $(mdl.ν)"

""" 
    smearFEM.gaussian_quadrature(a,b,nGaussPoints)

Compute the nodes and weights for the Gaussian quadrature of order 2
    
# Arguments:    
- `a,b::Integer` : the limits of the integration interval
- `nGaussPoints::Integer` : number of Gauss points to be considered (2 or 3)

# Returns:    
- `ξ::Vector{Float64}{,nGaussPoints}`: nodes.
- `w::Vector{Float64}{,nGaussPoints}`: weights 
"""
function gaussian_quadrature(a,b;nGaussPoints=2)
  
    if nGaussPoints == 2
        ξ = [-(b-a)/(2*sqrt(3))+(b+a)/2, (b-a)/(2*sqrt(3))+(b+a)/2]
        w = [(b-a)/2, (b-a)/2]
    elseif nGaussPoints == 3
        ξ = [-(b-a)/(2*sqrt(5/3))+(b+a)/2, 0, (b-a)/(2*sqrt(5/3))+(b+a)/2]
        w = [(b-a)/2*5/9, (b-a)/2*8/9, (b-a)/2*5/9]
    end
    return ξ, w
end

""" 
    basis_function(ξ,η=nothing,ζ=nothing,FunctionClass = "Q1")

Define the basis functions and the gradients for a master element

# Arguments:
- `ξ::Float64`: ξ coordinate of the point where the basis function is evaluated
- `η::Float64`: η coordinate of the point where the basis function is evaluated
- `ζ::Float64`: ζ coordinate of the point where the basis function is evaluated
- `FunctionClass::String`: type of basis functions to be considered (Q1:quadratic or Q2:Lagrange)

# Returns:
- `N::Vector{Float64}{,ndof}`: basis functions
- `Delta_N::Matrix{Float64}{ndof,ndim}`: gradient of the basis functions 
"""
function basis_function(ξ,η=nothing,ζ=nothing, FunctionClass = "Q2")
    
    if FunctionClass == "Q1" # bilinear quadratic basis functions
        if !isnothing(ζ) # Considering a 3D master element
            # basis functions
            N = [(1-ξ)*(1-η)*(1-ζ)/8, 
                (1+ξ)*(1-η)*(1-ζ)/8, 
                (1+ξ)*(1+η)*(1-ζ)/8, 
                (1-ξ)*(1+η)*(1-ζ)/8, 
                (1-ξ)*(1-η)*(1+ζ)/8, 
                (1+ξ)*(1-η)*(1+ζ)/8, 
                (1+ξ)*(1+η)*(1+ζ)/8, 
                (1-ξ)*(1+η)*(1+ζ)/8]

            # gradient of the basis functions
            ΔN = [[-(1-η)*(1-ζ)/8, (1-η)*(1-ζ)/8, (1+η)*(1-ζ)/8, -(1+η)*(1-ζ)/8, -(1-η)*(1+ζ)/8, (1-η)*(1+ζ)/8, (1+η)*(1+ζ)/8, -(1+η)*(1+ζ)/8] [-(1-ξ)*(1-ζ)/8, -(1+ξ)*(1-ζ)/8, (1+ξ)*(1-ζ)/8, (1-ξ)*(1-ζ)/8, -(1-ξ)*(1+ζ)/8, -(1+ξ)*(1+ζ)/8, (1+ξ)*(1+ζ)/8, (1-ξ)*(1+ζ)/8] [-(1-ξ)*(1-η)/8, -(1+ξ)*(1-η)/8, -(1+ξ)*(1+η)/8, -(1-ξ)*(1+η)/8, (1-ξ)*(1-η)/8, (1+ξ)*(1-η)/8, (1+ξ)*(1+η)/8, (1-ξ)*(1+η)/8]]  # [dN/dxi dN/deta dN/dzeta]
        elseif !isnothing(η) # Considering a 2D master element
            # basis functions
            N = [(1-ξ)*(1-η)/4, (ξ+1)*(1-η)/4, (1+ξ)*(η+1)/4, (1-ξ)*(1+η)/4]

            # gradient of the basis functions
            ΔN = [[-(1-η)/4 , (1-η)/4, (η+1)/4, -(1+η)/4] [-(1-ξ)/4, -(ξ+1)/4, (1+ξ)/4, (1-ξ)/4]]
        else # Considering a 1D master element
            # basis functions
            N  = [0.5-0.5*ξ, 0.5+0.5*ξ]

            # gradient of the basis functions
            ΔN = [-0.5 0.5]
        end
    elseif FunctionClass == "Q2" # Lagrange basis functions
        if !isnothing(ζ)
            N =[-(1-ξ)*  ξ  *(1-η)*  η  *(1-ζ)*  ζ/8, 
                   ξ  *(1+ξ)*(1-η)*  η  *(1-ζ)*  ζ/8, 
                -  ξ  *(1+ξ)*  η  *(1+η)*(1-ζ)*  ζ/8, 
                 (1-ξ)*  ξ  *  η  *(1+η)*(1-ζ)*  ζ/8,

                 (1-ξ)*  ξ  *(1-η)*  η  *  ζ  *(1+ζ)/8, 
                -  ξ  *(1+ξ)*(1-η)*  η  *  ζ  *(1+ζ)/8, 
                   ξ  *(1+ξ)*  η  *(1+η)*  ζ  *(1+ζ)/8, 
                -(1-ξ)*  ξ  *  η  *(1+η)*  ζ  *(1+ζ)/8,

                 (1-ξ)*(1+ξ)*(1-η)*  η  *(1-ζ)*  ζ/4,
                -  ξ  *(1+ξ)*(1-η)*(1+η)*(1-ζ)*  ζ/4,
                -(1-ξ)*(1+ξ)*  η  *(1+η)*(1-ζ)*  ζ/4,
                 (1-ξ)*  ξ  *(1-η)*(1+η)*(1-ζ)*  ζ/4,

                -(1-ξ)*(1+ξ)*(1-η)*  η  *  ζ  *(1+ζ)/4,
                   ξ  *(1+ξ)*(1-η)*(1+η)*  ζ  *(1+ζ)/4,
                 (1-ξ)*(1+ξ)*  η  *(1+η)*  ζ  *(1+ζ)/4,
                -(1-ξ)*  ξ  *(1-η)*(1+η)*  ζ  *(1+ζ)/4,

                 (1-ξ)*  ξ  *(1-η)*  η  *(1-ζ)*(1+ζ)/4, 
                -  ξ  *(1+ξ)*(1-η)*  η  *(1-ζ)*(1+ζ)/4, 
                   ξ  *(1+ξ)*  η  *(1+η)*(1-ζ)*(1+ζ)/4, 
                -(1-ξ)*  ξ  *  η  *(1+η)*(1-ζ)*(1+ζ)/4,

                -(1-ξ)*(1+ξ)*(1-η)*  η  *(1-ζ)*(1+ζ)/2,
                   ξ  *(1+ξ)*(1-η)*(1+η)*(1-ζ)*(1+ζ)/2,
                 (1-ξ)*(1+ξ)*  η  *(1+η)*(1-ζ)*(1+ζ)/2,
                -(1-ξ)*  ξ  *(1-η)*(1+η)*(1-ζ)*(1+ζ)/2,

                -(1-ξ)*(1+ξ)*(1-η)*(1+η)*(1-ζ)*  ζ/2,
                 (1-ξ)*(1+ξ)*(1-η)*(1+η)*  ζ  *(1+ζ)/2,
                 (1-ξ)*(1+ξ)*(1-η)*(1+η)*(1-ζ)*(1+ζ)]

            ∂N_ξ = [-(1-2*ξ)*(1-η)*  η  *(1-ζ)*  ζ/8, 
                     (1+2*ξ)*(1-η)*  η  *(1-ζ)*  ζ/8, 
                    -(1+2*ξ)*  η  *(1+η)*(1-ζ)*  ζ/8, 
                     (1-2*ξ)*  η  *(1+η)*(1-ζ)*  ζ/8,

                     (1-2*ξ)*(1-η)*  η  *  ζ  *(1+ζ)/8, 
                    -(1+2*ξ)*(1-η)*  η  *  ζ  *(1+ζ)/8, 
                     (1+2*ξ)*  η  *(1+η)*  ζ  *(1+ζ)/8, 
                    -(1-2*ξ)*  η  *(1+η)*  ζ  *(1+ζ)/8,

                     (-2*ξ) *(1-η)*  η  *(1-ζ)*  ζ/4,
                    -(1+2*ξ)*(1-η)*(1+η)*(1-ζ)*  ζ/4,
                    -(-2*ξ) *  η  *(1+η)*(1-ζ)*  ζ/4,
                     (1-2*ξ)*(1-η)*(1+η)*(1-ζ)*  ζ/4,

                    -(-2*ξ) *(1-η)*  η  *  ζ  *(1+ζ)/4,
                     (1+2*ξ)*(1-η)*(1+η)*  ζ  *(1+ζ)/4,
                     (-2*ξ) *  η  *(1+η)*  ζ  *(1+ζ)/4,
                    -(1-2*ξ)*(1-η)*(1+η)*  ζ  *(1+ζ)/4,

                     (1-2*ξ)*(1-η)*  η  *(1-ζ)*(1+ζ)/4, 
                    -(1+2*ξ)*(1-η)*  η  *(1-ζ)*(1+ζ)/4, 
                     (1+2*ξ)*  η  *(1+η)*(1-ζ)*(1+ζ)/4, 
                    -(1-2*ξ)*  η  *(1+η)*(1-ζ)*(1+ζ)/4,

                    -(-2*ξ) *(1-η)*  η  *(1-ζ)*(1+ζ)/2,
                     (1+2*ξ)*(1-η)*(1+η)*(1-ζ)*(1+ζ)/2,
                     (-2*ξ) *  η  *(1+η)*(1-ζ)*(1+ζ)/2,
                    -(1-2*ξ)*(1-η)*(1+η)*(1-ζ)*(1+ζ)/2,

                    -(-2*ξ)*(1-η)*(1+η)*(1-ζ)  *ζ/2,
                     (-2*ξ)*(1-η)*(1+η)*  ζ  *(1+ζ)/2,
                     (-2*ξ)*(1-η)*(1+η)*(1-ζ)*(1+ζ)]

            ∂N_η = [-(1-ξ)*  ξ  *(1-2*η)*(1-ζ)*  ζ/8, 
                       ξ  *(1+ξ)*(1-2*η)*(1-ζ)*  ζ/8, 
                    -  ξ  *(1+ξ)*(1+2*η)*(1-ζ)*  ζ/8, 
                     (1-ξ)*  ξ  *(1+2*η)*(1-ζ)*  ζ/8,

                     (1-ξ)*  ξ  *(1-2*η)*  ζ  *(1+ζ)/8, 
                    -  ξ  *(1+ξ)*(1-2*η)*  ζ  *(1+ζ)/8, 
                       ξ  *(1+ξ)*(1+2*η)*  ζ  *(1+ζ)/8, 
                    -(1-ξ)*  ξ  *(1+2*η)*  ζ  *(1+ζ)/8,

                     (1-ξ)*(1+ξ)*(1-2*η)*(1-ζ)*  ζ/4,
                    -  ξ  *(1+ξ)*(-2*η) *(1-ζ)*  ζ/4,
                    -(1-ξ)*(1+ξ)*(1+2*η)*(1-ζ)*  ζ/4,
                     (1-ξ)*  ξ  *(-2*η) *(1-ζ)*  ζ/4,

                    -(1-ξ)*(1+ξ)*(1-2*η)*  ζ  *(1+ζ)/4,
                       ξ  *(1+ξ)*(-2*η) *  ζ  *(1+ζ)/4,
                     (1-ξ)*(1+ξ)*(1+2*η)*  ζ  *(1+ζ)/4,
                    -(1-ξ)*  ξ  *(-2*η) *  ζ  *(1+ζ)/4,

                     (1-ξ)*  ξ  *(1-2*η)*(1-ζ)*(1+ζ)/4, 
                    -  ξ  *(1+ξ)*(1-2*η)*(1-ζ)*(1+ζ)/4, 
                       ξ  *(1+ξ)*(1+2*η)*(1-ζ)*(1+ζ)/4, 
                    -(1-ξ)*  ξ  *(1+2*η)*(1-ζ)*(1+ζ)/4,

                    -(1-ξ)*(1+ξ)*(1-2*η)*(1-ζ)*(1+ζ)/2,
                       ξ  *(1+ξ)*(-2*η) *(1-ζ)*(1+ζ)/2,
                     (1-ξ)*(1+ξ)*(1+2*η)*(1-ζ)*(1+ζ)/2,
                    -(1-ξ)*  ξ  *(-2*η) *(1-ζ)*(1+ζ)/2,

                    -(1-ξ)*(1+ξ)*(-2*η)*(1-ζ)*  ζ/2,
                     (1-ξ)*(1+ξ)*(-2*η)*  ζ  *(1+ζ)/2,
                     (1-ξ)*(1+ξ)*(-2*η)*(1-ζ)*(1+ζ)]

            ∂N_ζ = [-(1-ξ)*  ξ  *(1-η)*  η  *(1-2*ζ)/8, 
                       ξ  *(1+ξ)*(1-η)*  η  *(1-2*ζ)/8, 
                    -  ξ  *(1+ξ)*  η  *(1+η)*(1-2*ζ)/8, 
                     (1-ξ)*  ξ  *  η  *(1+η)*(1-2*ζ)/8,

                     (1-ξ)*  ξ  *(1-η)*  η  *(1+2*ζ)/8, 
                    -  ξ  *(1+ξ)*(1-η)*  η  *(1+2*ζ)/8, 
                       ξ  *(1+ξ)*  η  *(1+η)*(1+2*ζ)/8, 
                    -(1-ξ)*  ξ  *  η  *(1+η)*(1+2*ζ)/8,

                     (1-ξ)*(1+ξ)*(1-η)*  η  *(1-2*ζ)/4,
                    -  ξ  *(1+ξ)*(1-η)*(1+η)*(1-2*ζ)/4,
                    -(1-ξ)*(1+ξ)*  η  *(1+η)*(1-2*ζ)/4,
                     (1-ξ)*  ξ  *(1-η)*(1+η)*(1-2*ζ)/4,

                    -(1-ξ)*(1+ξ)*(1-η)*  η  *(1+2*ζ)/4,
                       ξ  *(1+ξ)*(1-η)*(1+η)*(1+2*ζ)/4,
                     (1-ξ)*(1+ξ)*  η  *(1+η)*(1+2*ζ)/4,
                    -(1-ξ)*  ξ  *(1-η)*(1+η)*(1+2*ζ)/4,

                     (1-ξ)*  ξ  *(1-η)*  η  *(-2*ζ)/4, 
                    -  ξ  *(1+ξ)*(1-η)*  η  *(-2*ζ)/4, 
                       ξ  *(1+ξ)*  η  *(1+η)*(-2*ζ)/4, 
                    -(1-ξ)*  ξ  *  η  *(1+η)*(-2*ζ)/4,

                    -(1-ξ)*(1+ξ)*(1-η)*  η  *(-2*ζ)/2,
                       ξ  *(1+ξ)*(1-η)*(1+η)*(-2*ζ)/2,
                     (1-ξ)*(1+ξ)*  η  *(1+η)*(-2*ζ)/2,
                    -(1-ξ)*  ξ  *(1-η)*(1+η)*(-2*ζ)/2,

                    -(1-ξ)*(1+ξ)*(1-η)*(1+η)*(1-2*ζ)/2,
                     (1-ξ)*(1+ξ)*(1-η)*(1+η)*(1+2*ζ)/2,
                     (1-ξ)*(1+ξ)*(1-η)*(1+η)* (-2*ζ)]

            ΔN = [∂N_ξ ∂N_η ∂N_ζ] # [dN/dξ dN/dη dN/dζ]

        elseif !isnothing(η) # Considering a 2D master element
            # basis functions
            N = [(1-ξ)*  ξ  *(1-η)*  η/4, 
                -  ξ  *(1+ξ)*(1-η)*  η/4, 
                   ξ  *(1+ξ)*  η  *(1+η)/4, 
                -(1-ξ)*  ξ  *  η  *(1+η)/4,

                -(1-ξ)*(1+ξ)*(1-η)*  η/2,
                   ξ  *(1+ξ)*(1-η)*(1+η)/2,
                 (1-ξ)*(1+ξ)*  η  *(1+η)/2,
                -(1-ξ)*  ξ  *(1-η)*(1+η)/2,

                 (1-ξ)*(1+ξ)*(1-η)*(1+η)] # gradient of the basis functions

            ∂N_ξ = [ (1-2*ξ)*(1-η)*  η/4, 
                    -(1+2*ξ)*(1-η)*  η/4, 
                     (1+2*ξ)*  η  *(1+η)/4, 
                    -(1-2*ξ)*  η  *(1+η)/4,

                        ξ   *(1-η)*  η,
                     (1+2*ξ)*(1-η)*(1+η)/2,
                    -   ξ   *  η  *(1+η),
                    -(1-2*ξ)*(1-η)*(1+η)/2,

                    -2*  ξ  *(1-η)*(1+η)] # ∂N/∂ξ gradient of the basis functions
                
            ∂N_η = [(1-ξ)*  ξ  *(1-2*η)/4, 
                   -  ξ  *(1+ξ)*(1-2*η)/4, 
                      ξ  *(1+ξ)*(1+2*η)/4, 
                   -(1-ξ)*  ξ  *(1+2*η)/4,

                   -(1-ξ)*(1+ξ)*(1-2*η)/2,
                   -  ξ  *(1+ξ)*  η,
                    (1-ξ)*(1+ξ)*(1+2*η)/2,
                    (1-ξ)*  ξ  *  η,

                   -(1-ξ)*(1+ξ)*2*η] # ∂N/∂η gradient of the basis functions
                
            ΔN = [∂N_ξ ∂N_η] # [dN/dξ dN/dη]
        end
    end
    return N, ΔN
end
